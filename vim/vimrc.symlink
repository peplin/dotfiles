" first clear any existing autocommands:
autocmd!

call pathogen#runtime_append_all_bundles()
call pathogen#helptags()

colors blackboard

" * User Interface

syntax on

" have 100 lines of command-line (etc) history:
set history=100

" remember all of these between sessions, but only 50 search terms; also
" remember info for 50 files, but never any on removable disks, don't remember
" marks in files, don't rehighlight old search patterns, and only save up to
" 100 lines of registers; including @10 in there should restrict input buffer
" but it causes an error for me:
set viminfo=/50,'50,r/mnt/zip,r/mnt/floppy,f0,h,\"100

" have command-line completion <Tab> (for filenames, help topics, option names)
" first list the available options and complete the longest common part, then
" have further <Tab>s cycle through the possibilities:
set wildmode=list:longest,full
set wildignore=*.o,*~,*.pyc

" use "[RO]" for "[readonly]" to save space in the message line:
set shortmess+=r

" display the current mode and partially-typed commands in the status line:
set showmode
set showcmd

" don't have files trying to override this .vimrc:
set nomodeline

" * Text Formatting -- General

" don't make it look like there are line breaks where there aren't:
set nowrap

" use indents of 4 spaces, and have them copied down lines:
set shiftwidth=4
set tabstop=4
set shiftround
set expandtab
set autoindent
set smarttab

set laststatus=2
set statusline=
set statusline+=%-3.3n\                      " buffer number
set statusline+=%f\                          " filename
set statusline+=%h%m%r%w                     " status flags
set statusline+=\[%{strlen(&ft)?&ft:'none'}] " file type
set statusline+=\ %{fugitive#statusline()}     " fugitive
set statusline+=%=                           " right align remainder
set statusline+=%-14(%l,%c%V%)               " line, character
set statusline+=%<%P                         " file position

set hidden

set formatoptions+=t
set textwidth=80

" get rid of the default style of C comments, and define a style with two stars
" at the start of `middle' rows which (looks nicer and) avoids asterisks used
" for bullet lists being treated like C comments; then define a bullet list
" style for single stars (like already is for hyphens):
set comments+=fb:*

" treat lines starting with a quote mark as comments (for `Vim' files, such as
" this very one!), and colons as well so that reformatting usenet messages from
" `Tin' users works OK:
set comments+=b:\"

" * Text Formatting -- Specific File Formats

" enable filetype detection:
filetype on
filetype plugin on

" recognize anything at all with a .txt extension as being human-language text 
" [this clobbers the `help' filetype, but that doesn't seem to prevent help
" from working properly]:
augroup filetype
  autocmd BufNewFile,BufRead *.txt set filetype=human
augroup END

" * Search & Replace

" make searches case-insensitive, unless they contain upper-case letters:
set ignorecase
set smartcase

" show the `best match so far' as search strings are typed:
set incsearch

" highlight search results in the document
set hlsearch

" assume the /g flag on :s substitutions to replace all matches in a line:
set gdefault

" * Keystrokes -- Moving Around

" have the h and l cursor keys wrap between lines (like <Space> and <BkSpc> do
" by default), and ~ covert case over line breaks; also have the cursor keys
" wrap in insert mode:
set whichwrap=h,l,~,[,]

" scroll the window (but leaving the cursor in the same place) by a couple of
" lines up/down with <Ins>/<Del> (like in `Lynx'):
" [<Ins> by default is like i, and <Del> like x.]
noremap <Ins> 2<C-Y>
noremap <Del> 2<C-E>

" use <Ctrl>+N/<Ctrl>+P to cycle through files:
" [<Ctrl>+N by default is like j, and <Ctrl>+P like k.]
nnoremap <C-N> :next<CR>
nnoremap <C-P> :prev<CR>

" have % bounce between angled brackets, as well as t'other kinds:
set matchpairs+=<:>

" * Keystrokes -- Formatting

" have Q reformat the current paragraph (or selected text if there is any):
nnoremap Q gqap
vnoremap Q gq

" have Y behave analogously to D and C rather than to dd and cc (which is
" already done by yy):
noremap Y y$

" * Keystrokes -- Toggles

" Keystrokes to toggle options are defined here.  They are all set to normal
" mode keystrokes beginning \t but some function keys (which won't work in all
" terminals) are also mapped.

" have \tp ("toggle paste") toggle paste on/off and report the change, and
" where possible also have <F4> do this both in normal and insert mode:
nnoremap \tp :set invpaste paste?<CR>
nmap <F4> \tp
imap <F4> <C-O>\tp
set pastetoggle=<F4>

" * Keystrokes -- Insert Mode

" have <Tab> (and <Shift>+<Tab> where it works) change the level of
" indentation:
inoremap <Tab> <C-T>
inoremap <S-Tab> <C-D>
" [<Ctrl>+V <Tab> still inserts an actual tab character.]

" Hit F5 to highlight lines longer than 80 characters
map <F5> /\%>80v.\+<CR>

" Highlight whitespace errors
" TODO enable this only for source code filetypes
highlight rightMargin ctermbg=red
highlight tabError ctermbg=red
highlight trailingSpace ctermbg=red
match rightMargin /.\%>81v/
"match trailingSpace /\s\+$/
"match tabError /\t/
match NonText /\s\s*$/

let Tlist_GainFocus_On_ToggleOpen=1
let Tlist_Process_File_Always=1
let Tlist_Show_Menu=1
let Tlist_Enable_Fold_Column=0
let g:gist_detect_filetype = 1

set grepprg=ack
set grepformat=%f:%l:%m

let mapleader=","
map <leader>d :execute 'NERDTreeToggle ' . getcwd()<CR>
map <leader>f :Ack\ 
map <leader>ws :%s/\s\+$//<CR>
map <Leader>s <Plug>Vsurround
map <Leader>S <Plug>Vsurround
map <Leader>om :call PreviewMKD()<CR>
map <leader>m :make<CR><CR>:copen<CR>
map <leader>v :vsp<CR>
map <leader>s :sp<CR>

let NERDTreeIgnore=['\.pyc$', '\~$', '\.png', '\.pdf']

" TODO ftdetect version of this isn't being picked up for some reason
au BufRead,BufNewFile *.mkd,*.md,*.txt  set filetype=mkd

map <leader>q :call QFixToggle()<CR>
function! QFixToggle()
  if exists("g:qfix_win")
    cclose
    unlet g:qfix_win
  else
    copen 10
    let g:qfix_win = bufnr("$")
  endif
endfunction

au BufEnter * call MyLastWindow()
function! MyLastWindow()
  " if the window is quickfix go on
  if &buftype=="quickfix"
    " if this window is last on screen quit without warning
    if winbufnr(2) == -1
      quit!
    endif
  endif
endfunction
