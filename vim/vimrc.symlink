" first clear any existing autocommands:
autocmd!

" Environment {
    " Basics {
        set nocompatible
        set ttyfast
    " }

    " Setup Vundle {
        filetype off
        set rtp+=~/.vim/bundle/Vundle.vim
        set rtp+=~/.fzf
        call vundle#begin()

        Plugin 'gmarik/Vundle.vim'

        " Core plugins
        Plugin 'Lokaltog/vim-easymotion'
        Plugin 'ConradIrwin/vim-bracketed-paste'
        Plugin 'scrooloose/nerdcommenter'
        Plugin 'scrooloose/syntastic'
        Plugin 'ervandew/supertab'
        Plugin 'tpope/vim-surround'
        Plugin 'tpope/vim-ragtag'
        Plugin 'tpope/vim-endwise'
        Plugin 'tpope/vim-repeat'
        Plugin 'tpope/vim-unimpaired'
        Plugin 'simnalamburt/vim-mundo'

        " Theme
        Plugin 'altercation/vim-colors-solarized'
        Plugin 'itchyny/lightline.vim'

        " Formatters
        Plugin 'hynek/vim-python-pep8-indent'
        Plugin 'rhysd/vim-clang-format'

        " Primary feature plugins
        Plugin 'airblade/vim-gitgutter'
        Plugin 'tpope/vim-fugitive'
        Plugin 'peplin/vim-phabrowse'
        Plugin 'Alok/notational-fzf-vim'

        " Candidates for retirement
        "Plugin 'rking/ag.vim'
        "Plugin 'mattn/gist-vim'

        " File types
        Plugin 'elzr/vim-json'
        Plugin 'tpope/vim-git'
        Plugin 'justinj/vim-pico8-syntax'
        " Faster YAML parsing
        Plugin 'stephpy/vim-yaml'
        "Plugin 'plasticboy/vim-markdown'
        "Plugin 'pangloss/vim-javascript'
        "Plugin 'mxw/vim-jsx'
        "Plugin 'uarun/vim-protobuf'

        Plugin 'ssh://code@code.int.uberatc.com/diffusion/VIMHIDL/vim-hidl-ftplugin.git'


        call vundle#end()
    " }
" }


" General {
    syntax on

    " how many lines of history to store
    set history=500

    " remember all of these between sessions, but only 50 search terms; also
    " remember info for 50 files, but never any on removable disks, don't
    " remember marks in files, don't rehighlight old search patterns, and only
    " save up to 100 lines of registers; including @10 in there should restrict
    " input buffer but it causes an error for me:
    set viminfo=/50,'50,r/mnt/zip,r/mnt/floppy,f0,h,\"100

    " use "[RO]" for "[readonly]" to save space in the message line:
    set shortmess+=IfilmnrxoOtT

    " don't have files trying to override this .vimrc:
    set nomodeline

    " save files when switching buffers or various other things
    set autowrite

    " reload files edited outside of vim automatically
    set autoread

    " Setting up the directories {
        " backups cause the file to be deleted + recreated in Dropbox, so
        " disable them
        set nobackup
        set nowritebackup
        set directory=$HOME/.vimswap//
        set undodir=$HOME/.vimundo//
        set undofile

        "" Creating directories if they don't exist
        silent execute '!mkdir -p $HOME/.vimundo'
        silent execute '!mkdir -p $HOME/.vimswap'

    " }

    " Don't wait so long for ambiguous command prefixes
    set timeoutlen=500

    ca Wq wq
    ca W w
    ca Q q
    ca Sp sp
" }

" Vim UI {
    if $COLORTERM == 'gnome-terminal' || $COLORTERM == 'Terminal'
      set t_Co=256
    endif

    if &t_Co == 256
        set background=dark
        colors solarized
        highlight SignColumn ctermbg=0
        call togglebg#map("<F4>")
    else
        colors wombat
    end

    " display the current mode and partially-typed commands in the status line:
    set showmode
    set showcmd
    set cursorline

    " show the ruler - because statusline is also set, this only effects the
    " output of CTRL-G
    set ruler
    set rulerformat=%30(%=\:b%n%y%m%r%w\ %l,%c%V\ %P%) " a ruler on steroids

    " Vertical line at 80 characters
    if exists('+colorcolumn')
        set colorcolumn=+1
    else
        au BufWinEnter * let w:m2=matchadd('ErrorMsg', '\%>81v.\+', -1)
    endif

    " show partial commands in status line and selected characters/lines in
    " visual mode
    set showcmd
    set laststatus=2

    " backspace for dummys
    set backspace=indent,eol,start
    " No extra spaces between rows
    set linespace=0
    " show matching brackets/parenthesis
    set showmatch
    set matchtime=3

    set confirm

    " Disable F1 shortcut for help
    nmap <F1> :echo<CR>
    imap <F1> <C-o>:echo<CR>

    " Layout / Text formatting {{{
        " Conflict markers {{{
            " Highlight conflict markers
            match ErrorMsg '^\(<\|=\|>\)\{7\}\([^=].\+\)\?$'

            " Shortcut to jump to next conflict marker
            nmap <silent> <leader>c /^\(<\\|=\\|>\)\{7\}\([^=].\+\)\?$<CR>
        " }}}
    " }}}

    " Search & Replace {
        " show the `best match so far' as search strings are typed:
        set incsearch

        " highlight search results in the document
        set hlsearch

        " make searches case-insensitive, unless they contain upper-case
        " letters:
        set ignorecase
        set smartcase

        " assume the /g flag on :s substitutions to replace all matches in a
        " line:
        set gdefault
    " }

    " show list instead of just completing
    set wildmenu

    " have command-line completion <Tab> (for filenames, help topics, option
    " names) first list the available options and complete the longest common
    " part, then have further <Tab>s cycle through the possibilities:
    set wildmode=list:longest
    set wildignore+=*.o,*~,*.pyc,*.class,__pycache__,*/node_modules/*,*/sent-mail/*,build,*/build/*,*/purepy/*,*/embedded/common/hal/*,*/build-stripped/*

    " lines to scroll when cursor leaves screen
    set scrolljump=5
    " minimum lines to keep above and below cursor
    set scrolloff=3

    " Window height and width minimums {
        set winwidth=10
        set winminwidth=10
        set winheight=5
        set winminheight=5
    " }
" }

" Folding {
    " auto fold code
    set foldenable
    set foldlevelstart=0

    " Space to toggle folds.
    nnoremap <Space> za
    vnoremap <Space> za
" }

" Formatting {
    " General {
        " don't make it look like there are line breaks where there aren't:
        set nowrap
        " use indents of 4 spaces
        set shiftwidth=4
        " tabs are spaces, not spaces
        set expandtab
        " an indentation every four columns
        set tabstop=4

        imap <S-Tab> <C-o><<

        " have % bounce between angled brackets, as well as t'other kinds:
        set matchpairs+=<:>

        " get rid of the default style of C comments, and define a style with
        " two stars at the start of `middle' rows which (looks nicer and) avoids
        " asterisks used for bullet lists being treated like C comments; then
        " define a bullet list style for single stars (like already is for
        " hyphens):
        set comments+=fb:*

        " treat lines starting with a quote mark as comments (for `Vim' files,
        " such as this very one!), and colons as well so that reformatting
        " usenet messages from `Tin' users works OK:
        set comments+=b:\"

        " Allow backgrounding buffers without writing them, and remember
        " marks/undo for backgrounded buffers
        set hidden

        set formatoptions+=t
        set textwidth=80

        " Don't insert two spaces after a sentence when joining lines.
        set nojoinspaces
    " }
    " Specific File Formats {
        " enable filetype detection:
        filetype on
        filetype plugin on
        filetype indent on
        filetype plugin indent on

        " recognize anything at all with a .txt extension as being
        " human-language text [this clobbers the `help' filetype, but that
        " doesn't seem to prevent help from working properly]:
        au BufNewFile,BufRead *.txt set filetype=human

        au BufNewFile,BufRead *.aidl set filetype=java

        au BufNewFile,BufRead *.ino set filetype=c
    " }
" }

" Key Mappings {

    let mapleader=","

    " Moving Around {

        " have the h and l cursor keys wrap between lines (like <Space> and
        " <BkSpc> do by default), and ~ covert case over line breaks; also have
        " the cursor keys wrap in insert mode:
        set whichwrap=h,l,~,[,]

        " scroll the window (but leaving the cursor in the same place) by a
        " couple of lines up/down with <Ins>/<Del> (like in `Lynx'): [<Ins> by
        " default is like i, and <Del> like x.]
        noremap <Ins> 2<C-Y>
        noremap <Del> 2<C-E>

        " use <Ctrl>+N/<Ctrl>+P to cycle through files:
        " [<Ctrl>+N by default is like j, and <Ctrl>+P like k.]
        nnoremap <C-N> :next<CR>
        nnoremap <C-P> :prev<CR>

        " Yank from the cursor to the end of the line, to be consistent with C
        " and D.
        nnoremap Y y$

        map <leader>v :vsp<CR>
        map <leader>s :sp<CR>

        " Easier moving in tabs and windows
        map <C-J> <C-W>j<C-W>_
        map <C-K> <C-W>k<C-W>_
        map <C-L> <C-W>l<C-W>_
        map <C-H> <C-W>h<C-W>_

        nnoremap <C-t> :tabnew<CR>
        nnoremap <C-q> :tabclose<CR>

        " Shortcuts
        " Change Working Directory to that of the current file
        cmap cwd lcd %:p:h

        " For when you forget to sudo.. Really Write the file.
        cmap w!! w !sudo tee % >/dev/null

        " Map ,e to open file in the same directory as the current file
        map <leader>e :edit %:p:h/

        nnoremap <silent> <Leader>w :w<CR>
    " }

    " Formatting {

        " have Q reformat the current paragraph (or selected text if there is
        " any):
        nnoremap Q gqap
        vnoremap Q gq

        " have Y behave analogously to D and C rather than to dd and cc (which
        " is already done by yy):
        noremap Y y$

        " remove trailing whitespace and blank line whitespace on write
        autocmd BufWritePre * :%s/\s\+$//e

        autocmd Filetype c,cpp set comments^=:///

    " }

    " Toggles {
        " Keystrokes to toggle options are defined here.  They are all set to
        " normal mode keystrokes beginning \t but some function keys (which
        " won't work in all terminals) are also mapped.

        " Hit F5 to highlight lines longer than 80 characters
        map <F5> /\%>80v.\+<CR>
    " }
    nnoremap ; :
" }

" Highlighting {
    " Highlight whitespace errors
    " TODO enable this only for source code filetypes
    highlight rightMargin ctermbg=red
    highlight tabError ctermbg=red
    highlight trailingSpace ctermbg=red
    match rightMargin /.\%>81v/
    match NonText /\s\s*$/
" }

" Plugins {
    " {
        map <leader>t :FZF<CR>
    " }

    " Gist {
        let g:gist_detect_filetype = 1
    " }

    " Syntastic {
        let g:syntastic_enable_signs=1
        let g:syntastic_mode_map = {'mode': 'active',
                    \ 'active_filetypes': [],
                    \ 'passive_filetypes': ["java"] }
        let g:syntastic_html_checkers=['tidy']
        let g:syntastic_javascript_checkers=['jslint']
        let g:syntastic_python_checkers=['flake8']
        let g:syntastic_python_flake8_args = "--max-line-length=120"
        let g:syntastic_cpp_include_dirs = ['source', 'build/source', '/usr/include', '/home/peplin/downloads/flycapture2-2.6.3.4-i386/usr/include', '/home/peplin/downloads/flycapture2-2.6.3.4-i386/usr/include/flycapture']
        let g:syntastic_cpp_compiler = 'clang++-3.5'
        let g:syntastic_cpp_compiler_options = ' -std=c++11'
        let g:syntastic_always_populate_loc_list = 1
        let g:syntastic_auto_loc_list = 0
        let g:syntastic_check_on_open = 1
        let g:syntastic_check_on_wq = 0

    " }

    " Ack {
        map <leader>f :Ag<space>
    " }
    "
    " vim-jsx {
        let g:jsx_ext_required = 0
    " }

    " NERDComment {
        "comment out line(s) in visual mode
        vmap  o  :call NERDComment(1, 'toggle')<CR>
        let g:NERDShutUp=1
        let NERDSpaceDelims = 1
    " }

    " notational-fzf {
        let g:nv_search_paths = ['~/Dropbox/notes']
        let g:nv_ignore_patterns = ['~/Dropbox/notes/archive/*']
        let g:nv_use_short_pathnames = 1

        map <leader>n :NV<CR>
    " }

    " EasyMotion {
        hi link EasyMotionShade  Comment
        let g:EasyMotion_leader_key = 'm'
    " }

    " gitgutter {
      let g:gitgutter_escape_grep = 1
    " }

    " Supertab {
        let g:SuperTabDefaultCompletionType = "<c-n>"
        let g:SuperTabLongestHighlight = 1
    " }

    " Java syntax highlighting {
        let g:java_allow_cpp_keywords = 1
    " }

    " vim-markdown {
        let g:vim_markdown_folding_disabled=1
        let g:vim_markdown_frontmatter=1
    " }

    " vim-phabrowse {
        let g:phabrowse_domains = ["https://code.int.uberatc.com"]
    " }

    " vim-clang-format {
    let g:clang_format#detect_style_file=1
    let g:clang_format#auto_formatexpr=0
    let g:clang_format#command="/opt/clang+llvm-3.8.0/bin/clang-format"
    let g:clang_format#style_options = {
                \ "BasedOnStyle" : "LLVM",
                \ "UseTab" : "Never",
                \ "IndentWidth" : 4,
                \ "BreakBeforeBraces" : "Attach",
                \ "AllowShortIfStatementsOnASingleLine" : "false",
                \ "IndentCaseLabels" : "false",
                \ "ColumnLimit" : 80,
                \ "PointerAlignment" : "Left",
                \ "AccessModifierOffset" : -4,
                \ "AllowShortLoopsOnASingleLine" : "false",
                \ "AllowShortFunctionsOnASingleLine" : "false",
                \ "MaxEmptyLinesToKeep" : 2,
                \ "Standard" : "Auto",
                \ "BreakConstructorInitializersBeforeComma" : "true"
                \}
    " }

    " vim-mundo {
    nnoremap <F6> :MundoToggle<CR>

    " }
" }

map <leader>q :call QFixToggle()<CR>
function! QFixToggle()
  if exists("g:qfix_win")
    cclose
    unlet g:qfix_win
  else
    copen 10
    let g:qfix_win = bufnr("$")
  endif
endfunction

au BufEnter * call MyLastWindow()
function! MyLastWindow()
  " if the window is quickfix go on
  if &buftype=="quickfix"
    " if this window is last on screen quit without warning
    if winbufnr(2) == -1
      quit!
    endif
  endif
endfunction

function! RenameFile()
    let old_name = expand('%')
    let new_name = input('New file name: ', expand('%'))
    if new_name != '' && new_name != old_name
        exec ':saveas ' . new_name
        exec ':silent !rm ' . old_name
        redraw!
    endif
endfunction
map <leader>m :call RenameFile()<cr>
